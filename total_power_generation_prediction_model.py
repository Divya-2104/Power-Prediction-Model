# -*- coding: utf-8 -*-
"""Total_Power_Generation_Prediction_Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eHnsSkOqrz6ans1-YnitOwqYsAXo8a3q
"""

import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

from google.colab import files
uploaded = files.upload()

df = pd.read_csv('dataset.csv')

# Convert the 'Date' column to datetime and set it as the index
df['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%Y')
df.set_index('Date', inplace=True)

# Data Preprocessing
df.fillna(method='ffill', inplace=True)

# Normalizing the dataset using MinMaxScaler
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(df[['Plant Day Gen (KWh)', 'Inverter Day Gen (KWh)',
                                       'Diff (Plant-Inverter) Day Gen (KWh)', 'Total Gen (KWh)',
                                       'Controlled PR (%)', 'Uncontrolled PR (%)']])

# Creating time series data for LSTM
def create_lstm_data(data, time_steps=10):
    X, y = [], []
    for i in range(len(data) - time_steps):
        X.append(data[i:(i + time_steps), :])
        y.append(data[i + time_steps, :])
    return np.array(X), np.array(y)

# Prepare the data
time_steps = 10
X, y = create_lstm_data(scaled_data, time_steps)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2,random_state=42, shuffle=False)

# Building the LSTM Model
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])))
model.add(LSTM(50))

model.add(Dense(6))  # Output for all 6 features
# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
history = model.fit(X_train, y_train, epochs=100, batch_size=32,validation_split=0.2, verbose=1)

# Make predictions
predictions = model.predict(X_test)

# Inverse transform the predictions
predictions_rescaled = scaler.inverse_transform(predictions)

# Select only the 'Total Gen (KWh)' column (index 3) after inverse transform
actual_values = scaler.inverse_transform(y_test)[:, 3]

# Create a DataFrame for actual and predicted values
results_df = pd.DataFrame({
    'Actual': actual_values,
    'Predicted': predictions_rescaled[:, 3] # Select the corresponding column from predictions_rescaled
}, index=df.index[-len(y_test):])  # Use actual data index for alignment

# Plotting
plt.figure(figsize=(16, 8))
plt.plot(df.index, df['Total Gen (KWh)'], label='Actual (Full Dataset)', color='blue')
plt.plot(results_df.index, results_df['Predicted'], label='Predicted', color='red', linestyle='--')
plt.title('Power Generation: Actual vs Predicted')
plt.xlabel('Date')
plt.ylabel('Power Generation (KWh)')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Calculate and plot residuals (assuming 'Total Gen' is the 4th column)
residuals = results_df['Actual'] - results_df['Predicted']
threshold = np.std(residuals) * 2

plt.figure(figsize=(16, 6))
plt.plot(results_df.index, residuals, label='Residuals', color='green')
plt.axhline(y=threshold, color='red', linestyle='--', label='Upper Threshold')
plt.axhline(y=-threshold, color='red', linestyle='--', label='Lower Threshold')
plt.title('Residuals')
plt.xlabel('Date')
plt.ylabel('Residuals (Actual - Predicted)')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Calculate residuals
residuals = results_df['Actual'] - results_df['Predicted']

# Ensure x and y have the same size for scatter plot
x = df.index[-len(residuals):]  # Use the same time frame as residuals

# Calculate Z-scores
z_scores = (residuals - np.mean(residuals)) / np.std(residuals)

# Set a threshold for outlier detection (e.g., 3)
threshold = 3

# Identify outliers
outliers = np.abs(z_scores) > threshold

# ... (rest of your code)

# Print the number of outliers
num_outliers = np.sum(outliers)
print(f'Total number of outliers: {num_outliers}')

# Visualize outliers (optional)
plt.figure(figsize=(12, 6))
plt.scatter(x, residuals, label='Residuals')
plt.scatter(x[outliers], residuals[outliers], label='Outliers', color='red')
plt.title('Residuals with Outliers')
plt.xlabel('Date')
plt.ylabel('Residuals')
plt.legend()
plt.grid(True)
plt.show()